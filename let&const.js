//首先要说的是，在ES5以前，包括ES5，我们只有可怜的两种声明方式，那就是经典的 var 和 function,但是现在我们就不同了，因为ES6给我们带来了新的声明方式，现在我们具有6中声明方式可以使用，分别是，var function let const import class,是不是觉得声明从此不再孤单，是的。这里要注意，除了前两种声明方式会提升以外，后面的四种都不会。

//let 类似于 var，但是比他强大

{
	let a = 2;
	var b = 3;
}
console.log(a);// 提示未声明
console.log(b);// 提示未定义

//上面的这个例子就很好的展示了两者的区别，这里两个变量是定义在一个大括号里面的，由于let不存在变量声明提升，且它只有在它定义的作用于没有效（ES6中，一个大括号就是一个作用于），所以你在括号外面声明他就是未声明，而var声明的b是存在提升的，所以是未定义，这个应该比较清楚；

//不允许重复定义一个变量

let a = 2; 
let a = 3;

//这种做法是不合法的，因为你let重复定义了一个a,这是语法规定的不合法，所以别问我为什么。


//暂时性死区

function add(){
	tem = "abc";
	let tem;
};

//这样声明的tem同样会报错，因为你在它声明以前就调用了它，给他赋值，人家当然就不开心了，这种因为变量不能提升，而形成的变量不能再声明前使用的现像就叫做暂时性死区

//块级作用域    ES5中没有快级作用于的概念，只有全局和函数作用域，但是ES6中有了，其中一个大括号就是一个作用于，看例子

{{{{{{let a = 2}}}}}};

//每一个大括号都是快级作用于，你自己数数这有多少个

//看个例子，来体会一下let和快级作用域的强大之处

for (let i = 0;i<6 ;i++){
	a[i] = function(){
		console.log(i)
	}
}

a[3]//结果是几呢？自己思考


//const  相对来说就要简单很多了，就是定义一个常量，用法和注意事项跟let一致，还有一点就是 const 声明的变量在你复过值后，就不能更改。、看例子：

const a = 2;
a = 3;//报错，告诉你const定义的变量是只读的。
